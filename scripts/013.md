이번 포스팅에서는 LiveData와 Observer Pattern에 대해 알아보도록 하겠습니다.

## LiveData의 개념

[LiveData](https://developer.android.com/reference/androidx/lifecycle/LiveData)는 간단히 말하면 값의 변경을 감지할 수 있는 데이터 홀더입니다. 예를들어 정수 1을 담고있는 `LiveData`의 값이 정수 2로 변하는 순간을 시스템이 감지할 수 있다는 말이죠. 

이 특징은 `ViewModel`과 결합할 때 시너지 효과를 얻을 수 있습니다. 이전 강의에서 UI에 표시할 데이터는 `ViewModel`에서 가져오고, 값이 변경되면 `ViewModel`을 확인하여 UI를 변경하는 구조를 채택하면 Activity 재생성에도 UI의 값을 유지할 수 있다는 것을 보였습니다. 

이 때 데이터 홀더로 `LiveData`를 사용하면 값의 변경을 감지하여 UI에 그 변화를 자동으로 반영되게 할 수 있습니다. 이것이 MVVM 구조에서 구현해야 하는 데이터바인딩의 개념입니다.

## Observer Pattern의 개념

Subject의 상태 변화를 관찰하는 Observer들을 객체와 연결하고, Subject의 상태 변화를 초래하는 Event가 발생하면 객체가 그 Event를 직접 Observer에게 통지하는 구조가 [디자인 패턴](https://en.wikipedia.org/wiki/Software_design_pattern)의 한 종류인 [Observer Pattern](https://en.wikipedia.org/wiki/Observer_pattern)입니다. 

유튜브를 예로 들면 채널 운영자는 Subject이고 구독자는 Observer입니다. 채널 운영자가 새로운 동영상을 등록하면 자동으로 구독자에게 알림 Event가 전달되어 구독자가 알게되는 것이 Observer Pattern이라고 할 수 있는것이죠. LiveData를 사용하는 것은 이 Observer Pattern을 구현하는 것과 같습니다.

![출처 : https://arjunsk.medium.com/observer-pattern-in-java-43e464249bed](https://miro.medium.com/max/900/1*FIwiE9wN5KHtnutjd0DNTQ.jpeg)

## Observable과 LiveData의 차이

[Observer](https://developer.android.com/reference/java/util/Observer)에 의해 값의 변경을 감시할 수 있는 안드로이드의 데이터 홀더로는 [Observable](https://developer.android.com/reference/java/util/Observable)과 `LiveData`가 있습니다. 

`Observable`에는 `ObservableBoolean`, `ObservableByte`, `ObservableChar` 등 기본형의 `Observable`은 이미 준비되어 있는데, 만약 특수한 타입을 사용하고 싶다면 [ObservableField](https://developer.android.com/reference/android/databinding/ObservableField)를 써서 직접 구현할 수도 있습니다. `Observable`은 다음과 같이 사용합니다.

```kotlin
private val observableString = ObservableField<String>("Default value")

observableString.addOnPropertyChangedCallback(object : Observable.OnPropertyChangedCallback() {
    override fun onPropertyChanged(sender: Observable?, propertyId: Int) {
        //Do something
    }
})
```

반면 `LiveData`의 사용법은 다음과 같습니다.

```kotlin
private val observableString = MutableLiveData<String>("Default value")

observableString.observe(lifecycleOwner, Observer {
    //Do something
})
```

구현을 보면 `ObservableField`는 콜백을 등록하는 과정이 있고, `LiveData`는 [lifecycleOwner](https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner)를 전달하는 과정이 있습니다. 이것이 `ObservableField`와 `LiveData`를 구분하는 가장 큰 차이점입니다.

`Observable`은 lifecycle을 알 수 없으므로 등록한 콜백이 상시 작동되어야 하며, 작동이 필요없어지면 [removeOnPropertyChangedCallback](https://developer.android.com/reference/android/databinding/Observable#removeonpropertychangedcallback)을 호출하여 콜백을 수동으로 직접 제거해야 하는 불편함이 있습니다. 

그러나 `LiveData`는 lifecycle이 `STARTED` 혹은 `RESUMED` 로 활성화 상태일 때만 observe를 수행하고 나머지 상태에서는 자동으로 비활성화합니다. 다음 그림을 보면 `STARTED`와 `RESUMED`는 결국 `onStart`와 `onStop`의 사이라는 것을 알 수 있습니다.

![출처 : https://developer.android.com/topic/libraries/architecture/lifecycle](https://developer.android.com/images/topic/libraries/architecture/lifecycle-states.svg)


## LiveData의 장점

LiveData는 Observable을 lifecycle과 연동하게 하면서 다음과 같은 수많은 [이점](https://developer.android.com/topic/libraries/architecture/livedata#the_advantages_of_using_livedata)을 갖게 되었습니다.

- UI와 데이터 상태의 일치 보장
  - LiveData는 관찰자 패턴을 따릅니다. LiveData는 기본 데이터가 변경될 때 Observer 객체에 알립니다. 코드를 통합하여 이러한 Observer 객체에 UI를 업데이트할 수 있습니다. 이렇게 하면 앱 데이터가 변경될 때마다 관찰자가 대신 UI를 업데이트하므로 개발자가 업데이트할 필요가 없습니다.
  
- 메모리 누수 없음
  - 관찰자는 Lifecycle 객체에 결합되어 있으며 연결된 수명 주기가 끝나면 자동으로 삭제됩니다.
  
- 중지된 활동으로 인한 비정상 종료 없음
  - 활동이 백 스택에 있을 때를 비롯하여 관찰자의 수명 주기가 비활성 상태에 있으면 관찰자는 어떤 LiveData 이벤트도 받지 않습니다.
  
- 수명 주기를 더 이상 수동으로 처리하지 않음
  - UI 구성요소는 관련 데이터를 관찰하기만 할 뿐 관찰을 중지하거나 다시 시작하지 않습니다. LiveData는 관찰하는 동안 관련 수명 주기 상태의 변경을 인식하므로 이 모든 것을 자동으로 관리합니다.
  
- 최신 데이터 유지
  - 수명 주기가 비활성화되면 다시 활성화될 때 최신 데이터를 수신합니다. 예를 들어 백그라운드에 있었던 활동은 포그라운드로 돌아온 직후 최신 데이터를 받습니다.
  
- 적절한 구성 변경
  - 기기 회전과 같은 구성 변경으로 인해 활동 또는 프래그먼트가 다시 생성되면 사용 가능한 최신 데이터를 즉시 받게 됩니다.
  
- 리소스 공유
  - 앱에서 시스템 서비스를 공유할 수 있도록 싱글톤 패턴을 사용하는 LiveData 객체를 확장하여 시스템 서비스를 래핑할 수 있습니다. LiveData 객체가 시스템 서비스에 한 번 연결되면 리소스가 필요한 모든 관찰자가 LiveData 객체를 볼 수 있습니다. 자세한 내용은 LiveData 확장을 참고하세요.

## ViewModel에 LiveData 도입

그럼 이전에 만들었던 ViewModel 프로젝트에 `LiveData`를 적용해 보겠습니다. 우선은 프로젝트에 LiveData dependency를 추가합니다.

```groovy
implementation "androidx.lifecycle:lifecycle-livedata-ktx:2.4.1"
```

ViewModel의 `counter`는 `liveCounter`로 대체합니다. 값을 변경해야 할 필요가 있는데 `LiveData`는 변경불가한 타입이므로 [MutableLiveData](https://developer.android.com/reference/androidx/lifecycle/MutableLiveData)를 사용하겠습니다.

```diff
class MyViewModel(_counter: Int) : ViewModel() {

-    var counter = _counter
+    val liveCounter : MutableLiveData<Int> = MutableLiveData(_counter)
}
```

그리고 메인액티비티에서 `LiveData`에 대해 `Observer`를 등록한 뒤 UI 업데이트 로직을 옮겨줍니다. 그럼 UI를 표시하는 로직을 더 이상 버튼의 클릭리스너 안에 둘 필요가 없게 됩니다.

```kotlin
binding.button.setOnClickListener {
    ...
    myViewModel.liveCounter.value = myViewModel.liveCounter.value?.plus(1)
}

myViewModel.liveCounter.observe(this) { counter ->
    binding.textView.text = counter.toString()
}
```

## LiveData 값 변경하기

`LiveData`는 값을 변경할 수 없는 타입입니다. 하지만 데이터를 다루다보면 `LiveData`의 값을 변경해야 할 일이 생기게 됩니다. 그런데 ViewModel이 데이터 원본을 조작하도록 하면 ViewModel과 데이터의 결합관계가 강해지는 문제가 생기게 됩니다.

이런 경우엔 [Transformations](https://developer.android.com/reference/androidx/lifecycle/Transformations)를 사용합니다. `Transformations`는 전달받은 `LiveData`에 변경이 일어났을 때 람다함수를 실행시킨 뒤 다시 `LiveData`를 반환합니다. 따라서 원본 데이터의 변경없이 새로운 `LiveData`를 만들어서 사용할 수 있습니다. 

`Transformations`에는 `map`과 `switchMap` 두 개의 메소드가 있습니다. [map](https://developer.android.com/reference/androidx/lifecycle/Transformations#map(androidx.lifecycle.LiveData%3CX%3E,%20androidx.arch.core.util.Function%3CX,%20Y%3E))의 사용법은 다음과 같습니다. `userLiveData`를 관찰하다 변화가 일어났을 때 `user.firstName + user.lastName`인 `LiveData`를 반환합니다.

```kotlin
val userLiveData = ...
val userNameLiveData: LiveData<String> = Transformations.map(userLiveData) { user ->
    user.firstName + user.lastName
}
```

[switchMap](https://developer.android.com/reference/androidx/lifecycle/Transformations#switchMap(androidx.lifecycle.LiveData%3CX%3E,%20androidx.arch.core.util.Function%3CX,%20androidx.lifecycle.LiveData%3CY%3E%3E))은 전달받은 LiveData의 값이 변경되면 mapping한 값도 따라서 변하는 특징을 갖고 있습니다.

```kotlin
val nameQueryLiveData = ...
val switchedNameQueryLiveData: LiveData<User> = Transformations.switchMap(nameQueryLiveData) { name ->
    myDataSource.getUsersWithNameLiveData(name)
}

fun setNameQuery(name: String) {
    nameQueryLiveData.setValue(name);
}
```

그럼 ViewModel에 적용해볼까요. `counter`에 "입니다"를 붙인 `modifiedCounter`를 새로 만들어 표시하도록 해 보겠습니다.

```kotlin
// MyViewModel.kt
val modifiedCounter : LiveData<String> = Transformations.map(liveCounter) { counter ->
    "$counter 입니다"
}

// MainActivity.kt
myViewModel.modifiedCounter.observe(this) { counter ->
    binding.textView.text = counter
}
```

이렇게 해서 LiveData와 Observer Pattern에 대해 알아보았습니다.
